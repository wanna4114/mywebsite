<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEURAL FLOW | Active Theory Style V6</title>
    <!-- 引入高阶字体 -->
    <link href="https://fonts.googleapis.com/css2?family=Syncopate:wght@700&family=Inter:wght@300;900&display=swap" rel="stylesheet">
    <style>
        :root { --accent: #00f2ff; --bg: #050505; }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body { 
            background: var(--bg); 
            color: #fff; 
            font-family: 'Inter', sans-serif; 
            overflow-x: hidden;
            user-select: none;
        }

        /* 核心 WebGL 画布 */
        #webgl-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1;
        }

        /* 鼠标跟随圆环 */
        #cursor {
            position: fixed;
            width: 40px;
            height: 40px;
            border: 1px solid var(--accent);
            border-radius: 50%;
            pointer-events: none;
            z-index: 9999;
            transform: translate(-50%, -50%);
            mix-blend-mode: difference;
            transition: transform 0.1s ease-out;
        }

        /* 内容层布局 */
        main { position: relative; z-index: 1; }

        section {
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 0 10%;
        }

        .hero-title {
            font-family: 'Syncopate', sans-serif;
            font-size: clamp(3rem, 12vw, 10rem);
            font-weight: 700;
            line-height: 0.85;
            text-transform: uppercase;
            text-align: center;
            letter-spacing: -0.05em;
            display: flex;
            flex-direction: column;
        }

        .hero-title span { display: block; overflow: hidden; }
        .hero-title i { font-style: normal; display: block; }

        .sub-text {
            margin-top: 2rem;
            font-size: 0.9rem;
            letter-spacing: 0.5em;
            color: var(--accent);
            text-transform: uppercase;
            opacity: 0.8;
        }

        .content-card {
            max-width: 500px;
            background: rgba(255,255,255,0.03);
            border-left: 2px solid var(--accent);
            padding: 40px;
            backdrop-filter: blur(20px);
            opacity: 0;
            transform: translateX(-50px);
        }

        .scroll-hint {
            position: absolute;
            bottom: 40px;
            font-size: 0.7rem;
            letter-spacing: 0.2em;
            color: #666;
        }
    </style>
</head>
<body>

    <div id="cursor"></div>
    <canvas id="webgl-canvas"></canvas>

    <main>
        <!-- 第一屏：震撼开场 -->
        <section>
            <div class="hero-title">
                <span><i class="t-up">NEURAL</i></span>
                <span><i class="t-up">FLOW</i></span>
            </div>
            <p class="sub-text">Beyond Digital Reality</p>
            <div class="scroll-hint">SCROLL TO IMMERSE</div>
        </section>

        <!-- 第二屏：交互感应 -->
        <section>
            <div class="content-card" id="card-trigger">
                <h2 style="font-family:'Syncopate'; margin-bottom:1rem;">LIQUID ENGINE</h2>
                <p style="color:#aaa; line-height:1.6;">每一个像素的扰动都由 GPU 进行流体计算。这不仅是设计，更是代码与艺术的深度交织。</p>
            </div>
        </section>

        <!-- 第三屏：结尾 -->
        <section>
            <h1 style="font-family:'Syncopate'; font-size:5vw;">FUTURE IS NOW</h1>
            <p style="margin-top:20px;">CONTACT@NEURALFLOW.IO</p>
        </section>
    </main>

    <!-- 依赖库 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>
    <script src="https://unpkg.com/lenis@1.0.28/dist/lenis.min.js"></script>

    <!-- 着色器代码 -->
    <script id="vertexShader" type="x-shader/x-vertex">
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = vec4(position, 1.0);
        }
    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">
        precision highp float;
        uniform float uTime;
        uniform vec2 uMouse;
        uniform vec2 uResolution;
        varying vec2 vUv;

        // 随机与噪波函数
        float rand(vec2 n) { return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); }
        
        void main() {
            vec2 uv = vUv;
            vec2 m = uMouse;
            
            // 基础流体算法
            float t = uTime * 0.5;
            vec2 distortedUv = uv;
            distortedUv.x += sin(uv.y * 10.0 + t) * 0.05;
            distortedUv.y += cos(uv.x * 10.0 + t) * 0.05;

            // 鼠标交互力场
            float dist = distance(uv, m);
            float strength = 1.0 / (dist * 10.0 + 1.0);
            
            // RGB 分离效果 (Active Theory 经典招牌)
            float r = rand(distortedUv + 0.01 * strength);
            float g = rand(distortedUv);
            float b = rand(distortedUv - 0.01 * strength);

            // 渐变色彩设计
            vec3 color1 = vec3(0.0, 0.9, 1.0); // 电光蓝
            vec3 color2 = vec3(0.5, 0.0, 1.0); // 幻影紫
            
            float noise = fract(sin(dot(distortedUv ,vec2(12.9898,78.233))) * 43758.5453);
            vec3 finalColor = mix(color1, color2, uv.y + strength);
            
            // 结合噪波和暗角
            finalColor *= noise * 0.2 + 0.8;
            finalColor *= (1.0 - dist * 0.5);
            
            gl_FragColor = vec4(finalColor * 0.5, 1.0);
        }
    </script>

    <script>
        // 1. WebGL 初始化
        const canvas = document.getElementById('webgl-canvas');
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);

        const scene = new THREE.Scene();
        const camera = new THREE.Camera();
        const geometry = new THREE.PlaneGeometry(2, 2);
        const uniforms = {
            uTime: { value: 0 },
            uMouse: { value: new THREE.Vector2(0.5, 0.5) },
            uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
        };

        const material = new THREE.ShaderMaterial({
            uniforms,
            vertexShader: document.getElementById('vertexShader').textContent,
            fragmentShader: document.getElementById('fragmentShader').textContent
        });

        const mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);

        // 2. 丝滑滚动 (Lenis)
        const lenis = new Lenis();
        function raf(time) {
            lenis.raf(time);
            requestAnimationFrame(raf);
        }
        requestAnimationFrame(raf);

        // 3. 鼠标交互
        window.addEventListener('mousemove', (e) => {
            const x = e.clientX / window.innerWidth;
            const y = 1.0 - (e.clientY / window.innerHeight);
            gsap.to(uniforms.uMouse.value, { x: x, y: y, duration: 1 });
            gsap.to('#cursor', { x: e.clientX, y: e.clientY, duration: 0.2 });
        });

        // 4. GSAP 动画序列
        gsap.registerPlugin(ScrollTrigger);

        // 入场动画
        gsap.from('.t-up', {
            y: 300,
            skewY: 20,
            duration: 2,
            stagger: 0.2,
            ease: "power4.out"
        });

        // 滚动卡片入场
        gsap.to('.content-card', {
            scrollTrigger: {
                trigger: '#card-trigger',
                start: "top 80%",
                end: "bottom 20%",
                toggleActions: "play reverse play reverse"
            },
            opacity: 1,
            x: 0,
            duration: 1
        });

        // 渲染循环
        function animate(time) {
            uniforms.uTime.value = time * 0.001;
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }
        animate();

        // 窗口适配
        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            uniforms.uResolution.value.set(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
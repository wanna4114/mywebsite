<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEURAL FLOW | 未来交互实验室</title>
    <!-- 引入字体 -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;900&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            background: #050505; 
            color: #fff; 
            font-family: 'Inter', sans-serif; 
            overflow-x: hidden;
            line-height: 1.2;
        }

        /* WebGL 背景容器 */
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            z-index: -1;
        }

        /* 内容布局 */
        section {
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 0 10%;
            position: relative;
        }

        .hero h1 {
            font-size: 8vw;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: -0.05em;
            opacity: 0;
            transform: translateY(100px);
        }

        .hero p {
            font-size: 1.2rem;
            color: #888;
            margin-top: 20px;
            opacity: 0;
        }

        .content-block {
            align-items: flex-start;
        }

        .content-block h2 {
            font-size: 4vw;
            margin-bottom: 2rem;
            background: linear-gradient(90deg, #fff, #444);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .scroll-hint {
            position: absolute;
            bottom: 30px;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.2em;
            color: #555;
        }

        /* 鼠标跟随效果 */
        #cursor {
            position: fixed;
            width: 20px;
            height: 20px;
            background: rgba(255,255,255,0.5);
            border-radius: 50%;
            pointer-events: none;
            z-index: 9999;
            mix-blend-mode: difference;
            transition: transform 0.1s;
        }
    </style>
</head>
<body>

    <div id="cursor"></div>
    <div id="canvas-container"></div>

    <main>
        <section class="hero">
            <h1>Neural Flow</h1>
            <p>越过屏幕，进入数字脉动。</p>
            <div class="scroll-hint">Scroll to Explore</div>
        </section>

        <section class="content-block">
            <h2>01. 模拟现实</h2>
            <p>我们不只是构建网页，我们正在创造一个充满感知的数字生态系统。</p>
        </section>

        <section class="content-block">
            <h2>02. 液态美学</h2>
            <p>受 Active Theory 启发，通过 WebGL 驱动每一帧像素的呼吸。</p>
        </section>

        <section class="hero">
            <h1>The Future</h1>
            <p>联系我们：hello@neuralflow.io</p>
        </section>
    </main>

    <!-- 脚本依赖 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>
    <script src="https://unpkg.com/lenis@1.0.28/dist/lenis.min.js"></script>

    <!-- WebGL 着色器代码 -->
    <script id="vertexShader" type="x-shader/x-vertex">
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">
        uniform float uTime;
        uniform vec2 uMouse;
        varying vec2 vUv;

        // 经典 Simplex Noise 函数 (为了篇幅精简版)
        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }

        float snoise(vec2 v) {
            const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
            vec2 i  = floor(v + dot(v, C.yy) );
            vec2 x0 = v -   i + dot(i, C.xx);
            vec2 i1;
            i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
            vec4 x12 = x0.xyxy + C.xxzz;
            x12.xy -= i1;
            i = mod289(i);
            vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));
            vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
            m = m*m ; m = m*m ;
            vec3 x = 2.0 * fract(p * C.www) - 1.0;
            vec3 h = abs(x) - 0.5;
            vec3 a0 = x - floor(x + 0.5);
            vec3 g = a0 * vec3(x0.x, x12.xz) + h * vec3(x0.y, x12.yw);
            return 130.0 * dot(m, g);
        }

        void main() {
            vec2 uv = vUv;
            // 创建扭曲流体感
            float n = snoise(uv * 3.0 + uTime * 0.2 + uMouse * 0.5);
            vec3 color = vec3(n * 0.1 + 0.02, n * 0.2 + 0.05, n * 0.3 + 0.1); // 深蓝色调
            // 加入交互光感
            float d = distance(uv, uMouse);
            color += (1.0 - smoothstep(0.0, 0.5, d)) * 0.15;
            gl_FragColor = vec4(color, 1.0);
        }
    </script>

    <script>
        // 1. 初始化 WebGL
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);

        const geometry = new THREE.PlaneGeometry(2, 2);
        const uniforms = {
            uTime: { value: 0 },
            uMouse: { value: new THREE.Vector2(0, 0) }
        };

        const material = new THREE.ShaderMaterial({
            uniforms: uniforms,
            vertexShader: document.getElementById('vertexShader').textContent,
            fragmentShader: document.getElementById('fragmentShader').textContent
        });

        const mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);

        // 2. 平滑滚动 (Lenis)
        const lenis = new Lenis();
        function raf(time) {
            lenis.raf(time);
            requestAnimationFrame(raf);
        }
        requestAnimationFrame(raf);

        // 3. 鼠标交互
        window.addEventListener('mousemove', (e) => {
            const x = e.clientX / window.innerWidth;
            const y = 1.0 - (e.clientY / window.innerHeight);
            gsap.to(uniforms.uMouse.value, { x: x, y: y, duration: 0.5 });
            gsap.to('#cursor', { x: e.clientX, y: e.clientY, duration: 0.1 });
        });

        // 4. 入场动画 (GSAP)
        const tl = gsap.timeline();
        tl.to('.hero h1', { opacity: 1, y: 0, duration: 1.5, ease: "power4.out" })
          .to('.hero p', { opacity: 1, duration: 1 }, "-=1");

        // 滚动触发
        gsap.utils.toArray('.content-block').forEach(block => {
            gsap.from(block, {
                scrollTrigger: {
                    trigger: block,
                    start: "top 80%",
                    scrub: true
                },
                opacity: 0,
                y: 100,
                filter: "blur(10px)"
            });
        });

        // 渲染循环
        function animate() {
            uniforms.uTime.value += 0.01;
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }
        animate();

        // 窗口缩放适配
        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>